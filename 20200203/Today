생성자 관련

┌>생성자와 연관성이 있음. 인스턴스의 멤버와도 있음.
this() , this.--------┘ 
this->나를 호출한 자기자신! 자기 인스턴스 주소를 기억하는 자기자신.
ㄴ주소호출. 인스턴스 참조. 
ㄴ누가 나를 불렀지???
this.this=>this=this
super(), super.--------
super() : 생성자와 연관되어 있다.
기초클래스의 생성자를 호출한다. 
기초클래스=부모클래스, 슈퍼클래스
super.----- : 인스턴스의 멤버와 연관성이 있다.
기초클래스의 변수를 불러온다.

this랑 super 둘 다 못 쓸 때: 일반 메소드를 만들어서 생성자에서 호출하도록 만들면 된다

생성자 호출할 때 쓴다
생성자 호출할 때 직접적으로 생성자 이름으로 호출할 수 ㄴㄴ
그래서 불러줘야 함
ex) a.b a에 속해있는 b

method.this:나를 호출한 method가 누구??

메서드는 호출해야지만 실행된다. 메소드는 자기를 호출한 애들 알고 있음.
인스턴스 안에 나를 호출하는 그릇이 있음(this)->기본적으로 생략됨. 이게 잡히면,,호출한 메소드를 알 수 있음!

static에서 this를 쓸 수 ㄴㄴ
ㄴ인스턴스instatnce가 만들어지기 전에 먼저 선점하니까(먼저 메모리 상에 할당됨)


생성자에서 일반메소드를 호출하도록 만든다
중복적인 로직을 가지는 코드 구문이 나온다면 메소드화 시켜서
호출해서 사용하도록 만든다


/////////////////////////////////////
멤버 변수, 멤버 메소드-중복?오버라이딩(재정의)?인지 
 기초클래스 슈퍼클래스
 age
 addr
 m1()
 m2()
 m2(int )
 서브클래스 자식클래스
  age
 addr ****
 m1() ->기초클래스꺼 오버라이딩(재정의)됨.
 m2() ****
 m2(int )
 ㄴ기초 클래스를 서브클래스에서 받을 수 있다
 마치 내것처럼 쓸 수 있음(불로소득 코드:addr, m2())
 
 age
 ㄴ상속관계에서 부모가 자식에게 상속받을 수 없다
 m1()
 m2(String)->this 아님. 상속받은 것이 아니므로.
 ㄴ상속받은 m2는 오버로딩됨. 상속받은값은 같으나 int, String 등 다른 값으로 출력되므로.
 output() ****
     m2():기초클래스 것을 가져다 쓸 수 o. this도 사용가능->왜?
 ㄴ슈퍼를 안쓰면 위의 것이 출력됨
 ****:서브클래스에서 기초클래스와 겹치지 않는 것
 
 ??????나 뭘 적은거임...존나 읽는데 이해가 안가벌임;;
 
 ////////////////////////////////////////////
 
 toString() : String화 시키는 것 중 한가지
 ㄴoverriding
 
 주의할 점: System.out.println(인스턴스를 써주면 toString()을 자동으로 호출함); //★★println에서만★★
 
 //////////////////////////////////////////////
 
 while(조건식 ) {
              반복할 것
              전후로 빠져나갈 문장이 필요함
 }
 
 for, while 빠져나갈 때 break;
 계속할 때 continue;
 
 
////////////////////////////////////////////////// 
 
 배열 
 array
 
 성적처리
 번호5
 이름5
 국어5
 영어5
 총점5
 
 아파트처럼 배열한 것
 int num1; 
 int num2;
 int num3;
 
 int [] nums = new int[ 수   ]; //배열을 참조할 변수.
 
 ㄴ 동일한 변수를 동일한 공간에 할당시켜 주는것.
 
 int[] nums = new int[    28   ];
 
 nums[인덱스번호 ]=데이터;
 num1=45;
 num2=78;
 num[28]=28;
 정수형 변수의 집합 = 배열;
 
 char


class Test1 {
String name;
String addr;

Test1 t1=new Test1(); //int num1;
Test2 t2=new Test2(); //int num2;

Test1 []  ts= new Test1[ 2 ];

ts[o] = new Test1();
ㄴ오른쪽 인스턴스 대신 쓸 수o 
 
 
 